/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { IChangePasswordAuthenticationRequest, IForgotPasswordAuthenticationRequest, ILoginAuthenticationRequest, IRegisterAuthenticationRequest } from "shared/src/interfaces/authentication.interface";
export namespace Components {
    interface AButton {
        /**
          * Set to true to draw the button with a caret for use with dropdowns, popovers, etc.
         */
        "caret": boolean;
        /**
          * Set to true to draw a circle button.
         */
        "circle": boolean;
        /**
          * Set to true to disable the button.
         */
        "disabled": boolean;
        /**
          * Tells the browser to download the linked file as this filename. Only used when `href` is set.
         */
        "download": string;
        /**
          * The button's height.
         */
        "height": 'small' | 'medium' | 'large';
        /**
          * When set, the underlying button will be rendered as an `<a>` with this `href` instead of a `<button>`.
         */
        "href": string;
        /**
          * Set to true to draw the button in a loading state.
         */
        "loading": boolean;
        /**
          * An optional name for the button. Ignored when `href` is set.
         */
        "name": string;
        /**
          * Set to true to draw a pill-style button with rounded edges.
         */
        "pill": boolean;
        /**
          * Removes focus from the button.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Sets focus on the button.
         */
        "setFocus": () => Promise<void>;
        /**
          * Tells the browser where to open the link. Only used when `href` is set.
         */
        "target": '_blank' | '_parent' | '_self' | '_top';
        /**
          * The button's type.
         */
        "type"?: 'submit' | 'button' | 'reset';
        /**
          * An optional value for the button. Ignored when `href` is set.
         */
        "value": string;
        /**
          * Button Variant
         */
        "variant": 'primary' | 'secondary' | 'tertiary' | 'ghost' | 'icon';
        /**
          * The button's width.
         */
        "width": 'default' | 'fullwidth';
    }
    interface AHelptext {
        "hasFocus": boolean;
        "validity": ValidityState;
    }
    interface AIcon {
        /**
          * Set the icon to hidden, respectively `true`, to remove it from the accessibility tree.
         */
        "ariaHidden"?: string;
        /**
          * Specifies the label to use for accessibility. Defaults to the icon name.
         */
        "ariaLabel"?: string;
        /**
          * The color to use for the background of the item.
         */
        "color"?: string;
        /**
          * Specifies whether the icon should horizontally flip when `dir` is `"rtl"`.
         */
        "flipRtl"?: boolean;
        /**
          * A combination of both `name` and `src`. If a `src` url is detected it will set the `src` property. Otherwise it assumes it's a built-in named SVG and set the `name` property.
         */
        "icon"?: 'string';
        /**
          * If enabled, ion-icon will be loaded lazily when it's visible in the viewport. Default, `false`.
         */
        "lazy": boolean;
        /**
          * Specifies which icon to use from the built-in set of icons.
         */
        "name"?: string;
        /**
          * The size of the icon. Available options are: `"small"` and `"large"`.
         */
        "size"?: 'small' | 'large';
        /**
          * Specifies the exact `src` of an SVG file to use.
         */
        "src"?: string;
    }
    interface AImage {
        "alt": string;
        "ioRootMargin": string;
        "src": { default: string; default2x: string; tablet: string; tablet2x: string; desktop: string; desktop2x: string; };
    }
    interface AInput {
        /**
          * The input's autocaptialize attribute.
         */
        "autocapitalize": string;
        /**
          * The input's autocomplete attribute.
         */
        "autocomplete": string;
        /**
          * The input's autocorrect attribute.
         */
        "autocorrect": string;
        /**
          * The input's autofocus attribute.
         */
        "autofocus": boolean;
        /**
          * Set to true to add a clear button when the input is populated.
         */
        "clearable": boolean;
        /**
          * Set to true to disable the input.
         */
        "disabled": boolean;
        /**
          * Host display
         */
        "hidden": boolean;
        /**
          * The input's inputmode attribute.
         */
        "inputmode": 'none' | 'text' | 'decimal' | 'numeric' | 'tel' | 'search' | 'email' | 'url';
        /**
          * The input's maximum value.
         */
        "max": number;
        /**
          * The maximum length of input that will be considered valid.
         */
        "maxlength": number;
        /**
          * The input's minimum value.
         */
        "min": number;
        /**
          * The minimum length of input that will be considered valid.
         */
        "minlength": number;
        /**
          * The input's name attribute.
         */
        "name": string;
        /**
          * A pattern to validate input against.
         */
        "pattern": string;
        /**
          * Set to true to draw a pill-style input with rounded edges.
         */
        "pill": boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder": string;
        /**
          * Set to true to make the input readonly.
         */
        "readonly": boolean;
        /**
          * Removes focus from the input.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Checks for validity and shows the browser's validation message if the control is invalid.
         */
        "reportValidity": () => Promise<ValidityState>;
        /**
          * Set to true to make the checkbox a required field.
         */
        "required": boolean;
        /**
          * Selects all the text in the input.
         */
        "select": () => Promise<void>;
        /**
          * Sets a custom validation message. If `message` is not empty, the field will be considered invalid.
         */
        "setCustomValidity": (message: string) => Promise<void>;
        /**
          * Sets focus on the input.
         */
        "setFocus": () => Promise<void>;
        /**
          * Replaces a range of text with a new string.
         */
        "setRangeText": (replacement: string, start: number, end: number, selectMode?: 'select' | 'start' | 'end' | 'preserve') => Promise<void>;
        /**
          * Sets the start and end positions of the text selection (0-based).
         */
        "setSelectionRange": (selectionStart: number, selectionEnd: number, selectionDirection?: 'forward' | 'backward' | 'none') => Promise<void>;
        /**
          * The input's size.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * The input's step attribute.
         */
        "step": number;
        /**
          * Set to true to add a password toggle button for password inputs.
         */
        "togglePassword": boolean;
        /**
          * The input's type.
         */
        "type": 'email' | 'number' | 'password' | 'search' | 'tel' | 'text' | 'url';
        /**
          * Input validity
         */
        "validity": ValidityState;
        /**
          * The input's value attribute.
         */
        "value": string;
    }
    interface ALabel {
        "hasFocus": boolean;
        "inputId": string;
        "labelId": string;
        "placeholder": string;
        "relative"?: boolean;
        "required": boolean;
        "valid": boolean;
        "value": string;
    }
    interface AppRoot {
    }
    interface MResponse {
        /**
          * Set to true to make the response closable.
         */
        "closable": boolean;
        /**
          * The content of response.
         */
        "content": any;
        /**
          * The length of time, in milliseconds, the response will show before closing itself. If the user interacts with the response before it closes (e.g. moves the mouse over it), the timer will restart.
         */
        "duration": number;
        /**
          * Indicates whether or not the response is hidden. You can use this in lieu of the show/hide methods.
         */
        "hidden": boolean;
        /**
          * Hides the response
         */
        "hide": () => Promise<void>;
        /**
          * Shows the response.
         */
        "show": () => Promise<void>;
        /**
          * Displays the response as a toast notification. This will move the response out of its position in the DOM and, when dismissed, it will be removed from the DOM completely. By storing a reference to the response, you can reuse it by calling this method again. The returned promise will resolve after the response is hidden.
         */
        "toast": () => Promise<unknown>;
        /**
          * The type of response.
         */
        "type": 'success' | 'info' | 'warning' | 'error';
    }
    interface OChangePassword {
        "autocomplete": 'on' | 'off';
        /**
          * Gets all form control elements (native and custom).
         */
        "getFormControls": () => Promise<HTMLElement[]>;
        /**
          * Serializes all form controls elements and returns a `FormData` object.
         */
        "getFormData": () => Promise<FormData>;
        /**
          * Prevent the form from validating inputs before submitting.
         */
        "novalidate": boolean;
        /**
          * Submits the form. If all controls are valid, the `slSubmit` event will be emitted and the promise will resolve with `true`. If any form control is invalid, the promise will resolve with `false` and no event will be emitted.
         */
        "submit": () => Promise<boolean>;
    }
    interface OForgotPassword {
        "autocomplete": 'on' | 'off';
        /**
          * Gets all form control elements (native and custom).
         */
        "getFormControls": () => Promise<HTMLElement[]>;
        /**
          * Serializes all form controls elements and returns a `FormData` object.
         */
        "getFormData": () => Promise<FormData>;
        /**
          * Prevent the form from validating inputs before submitting.
         */
        "novalidate": boolean;
        /**
          * Submits the form. If all controls are valid, the `slSubmit` event will be emitted and the promise will resolve with `true`. If any form control is invalid, the promise will resolve with `false` and no event will be emitted.
         */
        "submit": () => Promise<boolean>;
    }
    interface OHeader {
        "reduced": boolean;
    }
    interface OLogin {
        "autocomplete": 'on' | 'off';
        /**
          * Gets all form control elements (native and custom).
         */
        "getFormControls": () => Promise<HTMLElement[]>;
        /**
          * Serializes all form controls elements and returns a `FormData` object.
         */
        "getFormData": () => Promise<FormData>;
        /**
          * Prevent the form from validating inputs before submitting.
         */
        "novalidate": boolean;
        /**
          * Submits the form. If all controls are valid, the `slSubmit` event will be emitted and the promise will resolve with `true`. If any form control is invalid, the promise will resolve with `false` and no event will be emitted.
         */
        "submit": () => Promise<boolean>;
    }
    interface ORegister {
        "autocomplete": 'on' | 'off';
        /**
          * Gets all form control elements (native and custom).
         */
        "getFormControls": () => Promise<HTMLElement[]>;
        /**
          * Serializes all form controls elements and returns a `FormData` object.
         */
        "getFormData": () => Promise<FormData>;
        /**
          * Prevent the form from validating inputs before submitting.
         */
        "novalidate": boolean;
        /**
          * Submits the form. If all controls are valid, the `slSubmit` event will be emitted and the promise will resolve with `true`. If any form control is invalid, the promise will resolve with `false` and no event will be emitted.
         */
        "submit": () => Promise<boolean>;
    }
    interface PAuthVerify {
    }
    interface PChangePassword {
    }
    interface PForgotPassword {
    }
    interface PHome {
    }
    interface PLogin {
    }
    interface PProfile {
        "name": string;
    }
    interface PRegister {
    }
}
declare global {
    interface HTMLAButtonElement extends Components.AButton, HTMLStencilElement {
    }
    var HTMLAButtonElement: {
        prototype: HTMLAButtonElement;
        new (): HTMLAButtonElement;
    };
    interface HTMLAHelptextElement extends Components.AHelptext, HTMLStencilElement {
    }
    var HTMLAHelptextElement: {
        prototype: HTMLAHelptextElement;
        new (): HTMLAHelptextElement;
    };
    interface HTMLAIconElement extends Components.AIcon, HTMLStencilElement {
    }
    var HTMLAIconElement: {
        prototype: HTMLAIconElement;
        new (): HTMLAIconElement;
    };
    interface HTMLAImageElement extends Components.AImage, HTMLStencilElement {
    }
    var HTMLAImageElement: {
        prototype: HTMLAImageElement;
        new (): HTMLAImageElement;
    };
    interface HTMLAInputElement extends Components.AInput, HTMLStencilElement {
    }
    var HTMLAInputElement: {
        prototype: HTMLAInputElement;
        new (): HTMLAInputElement;
    };
    interface HTMLALabelElement extends Components.ALabel, HTMLStencilElement {
    }
    var HTMLALabelElement: {
        prototype: HTMLALabelElement;
        new (): HTMLALabelElement;
    };
    interface HTMLAppRootElement extends Components.AppRoot, HTMLStencilElement {
    }
    var HTMLAppRootElement: {
        prototype: HTMLAppRootElement;
        new (): HTMLAppRootElement;
    };
    interface HTMLMResponseElement extends Components.MResponse, HTMLStencilElement {
    }
    var HTMLMResponseElement: {
        prototype: HTMLMResponseElement;
        new (): HTMLMResponseElement;
    };
    interface HTMLOChangePasswordElement extends Components.OChangePassword, HTMLStencilElement {
    }
    var HTMLOChangePasswordElement: {
        prototype: HTMLOChangePasswordElement;
        new (): HTMLOChangePasswordElement;
    };
    interface HTMLOForgotPasswordElement extends Components.OForgotPassword, HTMLStencilElement {
    }
    var HTMLOForgotPasswordElement: {
        prototype: HTMLOForgotPasswordElement;
        new (): HTMLOForgotPasswordElement;
    };
    interface HTMLOHeaderElement extends Components.OHeader, HTMLStencilElement {
    }
    var HTMLOHeaderElement: {
        prototype: HTMLOHeaderElement;
        new (): HTMLOHeaderElement;
    };
    interface HTMLOLoginElement extends Components.OLogin, HTMLStencilElement {
    }
    var HTMLOLoginElement: {
        prototype: HTMLOLoginElement;
        new (): HTMLOLoginElement;
    };
    interface HTMLORegisterElement extends Components.ORegister, HTMLStencilElement {
    }
    var HTMLORegisterElement: {
        prototype: HTMLORegisterElement;
        new (): HTMLORegisterElement;
    };
    interface HTMLPAuthVerifyElement extends Components.PAuthVerify, HTMLStencilElement {
    }
    var HTMLPAuthVerifyElement: {
        prototype: HTMLPAuthVerifyElement;
        new (): HTMLPAuthVerifyElement;
    };
    interface HTMLPChangePasswordElement extends Components.PChangePassword, HTMLStencilElement {
    }
    var HTMLPChangePasswordElement: {
        prototype: HTMLPChangePasswordElement;
        new (): HTMLPChangePasswordElement;
    };
    interface HTMLPForgotPasswordElement extends Components.PForgotPassword, HTMLStencilElement {
    }
    var HTMLPForgotPasswordElement: {
        prototype: HTMLPForgotPasswordElement;
        new (): HTMLPForgotPasswordElement;
    };
    interface HTMLPHomeElement extends Components.PHome, HTMLStencilElement {
    }
    var HTMLPHomeElement: {
        prototype: HTMLPHomeElement;
        new (): HTMLPHomeElement;
    };
    interface HTMLPLoginElement extends Components.PLogin, HTMLStencilElement {
    }
    var HTMLPLoginElement: {
        prototype: HTMLPLoginElement;
        new (): HTMLPLoginElement;
    };
    interface HTMLPProfileElement extends Components.PProfile, HTMLStencilElement {
    }
    var HTMLPProfileElement: {
        prototype: HTMLPProfileElement;
        new (): HTMLPProfileElement;
    };
    interface HTMLPRegisterElement extends Components.PRegister, HTMLStencilElement {
    }
    var HTMLPRegisterElement: {
        prototype: HTMLPRegisterElement;
        new (): HTMLPRegisterElement;
    };
    interface HTMLElementTagNameMap {
        "a-button": HTMLAButtonElement;
        "a-helptext": HTMLAHelptextElement;
        "a-icon": HTMLAIconElement;
        "a-image": HTMLAImageElement;
        "a-input": HTMLAInputElement;
        "a-label": HTMLALabelElement;
        "app-root": HTMLAppRootElement;
        "m-response": HTMLMResponseElement;
        "o-change-password": HTMLOChangePasswordElement;
        "o-forgot-password": HTMLOForgotPasswordElement;
        "o-header": HTMLOHeaderElement;
        "o-login": HTMLOLoginElement;
        "o-register": HTMLORegisterElement;
        "p-auth-verify": HTMLPAuthVerifyElement;
        "p-change-password": HTMLPChangePasswordElement;
        "p-forgot-password": HTMLPForgotPasswordElement;
        "p-home": HTMLPHomeElement;
        "p-login": HTMLPLoginElement;
        "p-profile": HTMLPProfileElement;
        "p-register": HTMLPRegisterElement;
    }
}
declare namespace LocalJSX {
    interface AButton {
        /**
          * Set to true to draw the button with a caret for use with dropdowns, popovers, etc.
         */
        "caret"?: boolean;
        /**
          * Set to true to draw a circle button.
         */
        "circle"?: boolean;
        /**
          * Set to true to disable the button.
         */
        "disabled"?: boolean;
        /**
          * Tells the browser to download the linked file as this filename. Only used when `href` is set.
         */
        "download"?: string;
        /**
          * The button's height.
         */
        "height"?: 'small' | 'medium' | 'large';
        /**
          * When set, the underlying button will be rendered as an `<a>` with this `href` instead of a `<button>`.
         */
        "href"?: string;
        /**
          * Set to true to draw the button in a loading state.
         */
        "loading"?: boolean;
        /**
          * An optional name for the button. Ignored when `href` is set.
         */
        "name"?: string;
        /**
          * Emitted when the button loses focus.
         */
        "onEventBlur"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the button gains focus.
         */
        "onEventFocus"?: (event: CustomEvent<any>) => void;
        /**
          * Set to true to draw a pill-style button with rounded edges.
         */
        "pill"?: boolean;
        /**
          * Tells the browser where to open the link. Only used when `href` is set.
         */
        "target"?: '_blank' | '_parent' | '_self' | '_top';
        /**
          * The button's type.
         */
        "type"?: 'submit' | 'button' | 'reset';
        /**
          * An optional value for the button. Ignored when `href` is set.
         */
        "value"?: string;
        /**
          * Button Variant
         */
        "variant"?: 'primary' | 'secondary' | 'tertiary' | 'ghost' | 'icon';
        /**
          * The button's width.
         */
        "width"?: 'default' | 'fullwidth';
    }
    interface AHelptext {
        "hasFocus"?: boolean;
        "validity"?: ValidityState;
    }
    interface AIcon {
        /**
          * Set the icon to hidden, respectively `true`, to remove it from the accessibility tree.
         */
        "ariaHidden"?: string;
        /**
          * Specifies the label to use for accessibility. Defaults to the icon name.
         */
        "ariaLabel"?: string;
        /**
          * The color to use for the background of the item.
         */
        "color"?: string;
        /**
          * Specifies whether the icon should horizontally flip when `dir` is `"rtl"`.
         */
        "flipRtl"?: boolean;
        /**
          * A combination of both `name` and `src`. If a `src` url is detected it will set the `src` property. Otherwise it assumes it's a built-in named SVG and set the `name` property.
         */
        "icon"?: 'string';
        /**
          * If enabled, ion-icon will be loaded lazily when it's visible in the viewport. Default, `false`.
         */
        "lazy"?: boolean;
        /**
          * Specifies which icon to use from the built-in set of icons.
         */
        "name"?: string;
        /**
          * The size of the icon. Available options are: `"small"` and `"large"`.
         */
        "size"?: 'small' | 'large';
        /**
          * Specifies the exact `src` of an SVG file to use.
         */
        "src"?: string;
    }
    interface AImage {
        "alt"?: string;
        "ioRootMargin"?: string;
        "src"?: { default: string; default2x: string; tablet: string; tablet2x: string; desktop: string; desktop2x: string; };
    }
    interface AInput {
        /**
          * The input's autocaptialize attribute.
         */
        "autocapitalize"?: string;
        /**
          * The input's autocomplete attribute.
         */
        "autocomplete"?: string;
        /**
          * The input's autocorrect attribute.
         */
        "autocorrect"?: string;
        /**
          * The input's autofocus attribute.
         */
        "autofocus"?: boolean;
        /**
          * Set to true to add a clear button when the input is populated.
         */
        "clearable"?: boolean;
        /**
          * Set to true to disable the input.
         */
        "disabled"?: boolean;
        /**
          * Host display
         */
        "hidden"?: boolean;
        /**
          * The input's inputmode attribute.
         */
        "inputmode"?: 'none' | 'text' | 'decimal' | 'numeric' | 'tel' | 'search' | 'email' | 'url';
        /**
          * The input's maximum value.
         */
        "max"?: number;
        /**
          * The maximum length of input that will be considered valid.
         */
        "maxlength"?: number;
        /**
          * The input's minimum value.
         */
        "min"?: number;
        /**
          * The minimum length of input that will be considered valid.
         */
        "minlength"?: number;
        /**
          * The input's name attribute.
         */
        "name"?: string;
        /**
          * Emitted when the control loses focus.
         */
        "onEventBlur"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control's value changes.
         */
        "onEventChange"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the clear button is activated.
         */
        "onEventClear"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control gains focus.
         */
        "onEventFocus"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the control receives input.
         */
        "onEventInput"?: (event: CustomEvent<any>) => void;
        /**
          * A pattern to validate input against.
         */
        "pattern"?: string;
        /**
          * Set to true to draw a pill-style input with rounded edges.
         */
        "pill"?: boolean;
        /**
          * The input's placeholder text.
         */
        "placeholder"?: string;
        /**
          * Set to true to make the input readonly.
         */
        "readonly"?: boolean;
        /**
          * Set to true to make the checkbox a required field.
         */
        "required"?: boolean;
        /**
          * The input's size.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * The input's step attribute.
         */
        "step"?: number;
        /**
          * Set to true to add a password toggle button for password inputs.
         */
        "togglePassword"?: boolean;
        /**
          * The input's type.
         */
        "type"?: 'email' | 'number' | 'password' | 'search' | 'tel' | 'text' | 'url';
        /**
          * Input validity
         */
        "validity"?: ValidityState;
        /**
          * The input's value attribute.
         */
        "value"?: string;
    }
    interface ALabel {
        "hasFocus"?: boolean;
        "inputId"?: string;
        "labelId"?: string;
        "placeholder"?: string;
        "relative"?: boolean;
        "required"?: boolean;
        "valid"?: boolean;
        "value"?: string;
    }
    interface AppRoot {
    }
    interface MResponse {
        /**
          * Set to true to make the response closable.
         */
        "closable"?: boolean;
        /**
          * The content of response.
         */
        "content"?: any;
        /**
          * The length of time, in milliseconds, the response will show before closing itself. If the user interacts with the response before it closes (e.g. moves the mouse over it), the timer will restart.
         */
        "duration"?: number;
        /**
          * Indicates whether or not the response is hidden. You can use this in lieu of the show/hide methods.
         */
        "hidden"?: boolean;
        /**
          * Emitted after the response closes and all transitions are complete.
         */
        "onEventAfterHide"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted after the response opens and all transitions are complete.
         */
        "onEventAfterShow"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the response closes. Calling `event.preventDefault()` will prevent it from being closed.
         */
        "onEventHide"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the response opens. Calling `event.preventDefault()` will prevent it from being opened.
         */
        "onEventShow"?: (event: CustomEvent<any>) => void;
        /**
          * The type of response.
         */
        "type"?: 'success' | 'info' | 'warning' | 'error';
    }
    interface OChangePassword {
        "autocomplete"?: 'on' | 'off';
        /**
          * Prevent the form from validating inputs before submitting.
         */
        "novalidate"?: boolean;
        /**
          * Emitted when the form is submitted. This event will not be emitted if any form control inside of it is in an invalid state, unless the form has the `novalidate` attribute. Note that there is never a need to prevent this event, since it doen't send a GET or POST request like native forms. To "prevent" submission, use a conditional around the XHR request you use to submit the form's data with.
         */
        "onEventSubmit"?: (event: CustomEvent<any>) => void;
    }
    interface OForgotPassword {
        "autocomplete"?: 'on' | 'off';
        /**
          * Prevent the form from validating inputs before submitting.
         */
        "novalidate"?: boolean;
        /**
          * Emitted when the form is submitted. This event will not be emitted if any form control inside of it is in an invalid state, unless the form has the `novalidate` attribute. Note that there is never a need to prevent this event, since it doen't send a GET or POST request like native forms. To "prevent" submission, use a conditional around the XHR request you use to submit the form's data with.
         */
        "onEventSubmit"?: (event: CustomEvent<any>) => void;
    }
    interface OHeader {
        "reduced"?: boolean;
    }
    interface OLogin {
        "autocomplete"?: 'on' | 'off';
        /**
          * Prevent the form from validating inputs before submitting.
         */
        "novalidate"?: boolean;
        /**
          * Emitted when the form is submitted. This event will not be emitted if any form control inside of it is in an invalid state, unless the form has the `novalidate` attribute. Note that there is never a need to prevent this event, since it doen't send a GET or POST request like native forms. To "prevent" submission, use a conditional around the XHR request you use to submit the form's data with.
         */
        "onEventSubmit"?: (event: CustomEvent<any>) => void;
    }
    interface ORegister {
        "autocomplete"?: 'on' | 'off';
        /**
          * Prevent the form from validating inputs before submitting.
         */
        "novalidate"?: boolean;
        /**
          * Emitted when the form is submitted. This event will not be emitted if any form control inside of it is in an invalid state, unless the form has the `novalidate` attribute. Note that there is never a need to prevent this event, since it doen't send a GET or POST request like native forms. To "prevent" submission, use a conditional around the XHR request you use to submit the form's data with.
         */
        "onEventSubmit"?: (event: CustomEvent<any>) => void;
    }
    interface PAuthVerify {
    }
    interface PChangePassword {
    }
    interface PForgotPassword {
    }
    interface PHome {
    }
    interface PLogin {
    }
    interface PProfile {
        "name"?: string;
    }
    interface PRegister {
    }
    interface IntrinsicElements {
        "a-button": AButton;
        "a-helptext": AHelptext;
        "a-icon": AIcon;
        "a-image": AImage;
        "a-input": AInput;
        "a-label": ALabel;
        "app-root": AppRoot;
        "m-response": MResponse;
        "o-change-password": OChangePassword;
        "o-forgot-password": OForgotPassword;
        "o-header": OHeader;
        "o-login": OLogin;
        "o-register": ORegister;
        "p-auth-verify": PAuthVerify;
        "p-change-password": PChangePassword;
        "p-forgot-password": PForgotPassword;
        "p-home": PHome;
        "p-login": PLogin;
        "p-profile": PProfile;
        "p-register": PRegister;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "a-button": LocalJSX.AButton & JSXBase.HTMLAttributes<HTMLAButtonElement>;
            "a-helptext": LocalJSX.AHelptext & JSXBase.HTMLAttributes<HTMLAHelptextElement>;
            "a-icon": LocalJSX.AIcon & JSXBase.HTMLAttributes<HTMLAIconElement>;
            "a-image": LocalJSX.AImage & JSXBase.HTMLAttributes<HTMLAImageElement>;
            "a-input": LocalJSX.AInput & JSXBase.HTMLAttributes<HTMLAInputElement>;
            "a-label": LocalJSX.ALabel & JSXBase.HTMLAttributes<HTMLALabelElement>;
            "app-root": LocalJSX.AppRoot & JSXBase.HTMLAttributes<HTMLAppRootElement>;
            "m-response": LocalJSX.MResponse & JSXBase.HTMLAttributes<HTMLMResponseElement>;
            "o-change-password": LocalJSX.OChangePassword & JSXBase.HTMLAttributes<HTMLOChangePasswordElement>;
            "o-forgot-password": LocalJSX.OForgotPassword & JSXBase.HTMLAttributes<HTMLOForgotPasswordElement>;
            "o-header": LocalJSX.OHeader & JSXBase.HTMLAttributes<HTMLOHeaderElement>;
            "o-login": LocalJSX.OLogin & JSXBase.HTMLAttributes<HTMLOLoginElement>;
            "o-register": LocalJSX.ORegister & JSXBase.HTMLAttributes<HTMLORegisterElement>;
            "p-auth-verify": LocalJSX.PAuthVerify & JSXBase.HTMLAttributes<HTMLPAuthVerifyElement>;
            "p-change-password": LocalJSX.PChangePassword & JSXBase.HTMLAttributes<HTMLPChangePasswordElement>;
            "p-forgot-password": LocalJSX.PForgotPassword & JSXBase.HTMLAttributes<HTMLPForgotPasswordElement>;
            "p-home": LocalJSX.PHome & JSXBase.HTMLAttributes<HTMLPHomeElement>;
            "p-login": LocalJSX.PLogin & JSXBase.HTMLAttributes<HTMLPLoginElement>;
            "p-profile": LocalJSX.PProfile & JSXBase.HTMLAttributes<HTMLPProfileElement>;
            "p-register": LocalJSX.PRegister & JSXBase.HTMLAttributes<HTMLPRegisterElement>;
        }
    }
}
